use crate::ast;

grammar;

pub Program: ast::Program = {
    Decl* => ast::Program { decls: <> },  
};

Decl: ast::Decl = {
    StructDecl => ast::Decl::Struct(<>),
    FunDecl => ast::Decl::Fun(<>),
    VarDecl => ast::Decl::Var(<>),
    Stmt => ast::Decl::Stmt(<>),  
};

StructDecl: ast::StructDecl = {
    "struct" <ident:Ident> "{" <fns:FunDecl*> "}" => {
        ast::StructDecl {
            ident, fns,
        }
    }
};

FunDecl: ast::FunDecl = {
    "fn" <ident:Ident> "(" <params:Comma<Ident>> ")" <blk:Block> => {
        ast::FunDecl {
            ident, params, blk,
        }
    }
};

VarDecl: ast::VarDecl = {
    "let" <ident:Ident> "=" <expr:Expr> ";" => {
        ast::VarDecl { ident, expr }
    }  
};

Stmt: ast::Stmt = {
    "return" <Expr?> ";" => ast::Stmt::Return(<>),
    "break" <Expr?> ";" => ast::Stmt::Break(<>),
    Assignment => ast::Stmt::Assignment(<>),
    <Expr> ";" => ast::Stmt::Expr(<>),
};

Assignment: ast::Assignment = {
    <call:Call> <op:AssignOp> <expr:Expr> ";" => {
        ast::Assignment { call, op, expr }
    }
};

AssignOp: ast::AssignOp = {
    "=" => ast::AssignOp::Assign,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Mod,
    "&=" => ast::AssignOp::BitAnd,
    "|=" => ast::AssignOp::BitOr,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LeftShift,
    ">>=" => ast::AssignOp::RightShift,
    "&&=" => ast::AssignOp::LogicAnd,
    "||=" => ast::AssignOp::LogicOr,
};

Expr: ast::Expr = {
    LogicOr => ast::Expr{ or: <> },
};

LogicOr: ast::LogicOr = {
    LogicAnd => ast::LogicOr::A(<>),
    <left:LogicOr> "||" <right:LogicAnd> => {
        ast::LogicOr::B { left: Box::new(left), right }
    }
};

LogicAnd: ast::LogicAnd = {
    Cmp => ast::LogicAnd::A(<>),
    <left:LogicAnd> "&&" <right:Cmp> => {
        ast::LogicAnd::B { left: Box::new(left), right }
    }
};

Cmp: ast::Cmp = {
    BitOr => ast::Cmp::A(<>),
    <left:Cmp> <op:CmpOp> <right:BitOr> => {
        ast::Cmp::B { left: Box::new(left), op, right }
    }  
};

CmpOp: ast::CmpOp = {
    "==" => ast::CmpOp::Eq,
    "!=" => ast::CmpOp::NotEq,
    "<" => ast::CmpOp::Less,
    ">" => ast::CmpOp::Grt,
    "<=" => ast::CmpOp::LessEq,
    ">=" => ast::CmpOp::GrtEq,
};

BitOr: ast::BitOr = {
    BitXor => ast::BitOr::A(<>),
    <left:BitOr> "|" <right:BitXor> => {
        ast::BitOr::B { left: Box::new(left), right }
    }
};

BitXor: ast::BitXor = {
    BitAnd => ast::BitXor::A(<>),
    <left:BitXor> "^" <right:BitAnd> => {
        ast::BitXor::B { left: Box::new(left), right }
    }
};

BitAnd: ast::BitAnd = {
    Shift => ast::BitAnd::A(<>),
    <left:BitAnd> "&" <right:Shift> => {
        ast::BitAnd::B { left: Box::new(left), right }
    }
};

Shift: ast::Shift = {
    Term => ast::Shift::A(<>),
    <left:Shift> <op:ShiftOp> <right:Term> => {
        ast::Shift::B { left: Box::new(left), op, right }
    }
};

ShiftOp: ast::ShiftOp = {
    ">>" => ast::ShiftOp::Right,
    "<<" => ast::ShiftOp::Left,  
};

Term: ast::Term = {
    Factor => ast::Term::A(<>),
    <left:Term> <op:TermOp> <right:Factor> => {
        ast::Term::B { left: Box::new(left), op, right }
    }
};

TermOp: ast::TermOp = {
    "+" => ast::TermOp::Add,
    "-" => ast::TermOp::Sub,  
};

Factor: ast::Factor = {
    TypeCast => ast::Factor::A(<>),
    <left:Factor> <op:FactorOp> <right:TypeCast> => {
        ast::Factor::B { left: Box::new(left), op, right }
    }
};

FactorOp: ast::FactorOp = {
    "*" => ast::FactorOp::Mul,
    "/" => ast::FactorOp::Div,
    "%" => ast::FactorOp::Mod,  
};

TypeCast: ast::TypeCast = {
    Unary => ast::TypeCast::A(<>),
    <left:TypeCast> "as" <type_name:TypeName> => {
        ast::TypeCast::B { left: Box::new(left), type_name }
    }  
};

TypeName: ast::TypeName = {
    "bool" => ast::TypeName::Bool,
    "int" => ast::TypeName::Int,
    "float" => ast::TypeName::Float,
    "function" => ast::TypeName::Function,
    "closure" => ast::TypeName::Closure,
    "map" => ast::TypeName::Map,
    "array" => ast::TypeName::Array,
    Ident => ast::TypeName::Ident(<>),
};

Unary: ast::Unary = {
    Call => ast::Unary::A(<>),  
    <op:UnaryOp> <unary:Unary> => {
        ast::Unary::B { op, unary: Box::new(unary) }
    }
};

UnaryOp: ast::UnaryOp = {
    "-" => ast::UnaryOp::Minus,
    "!" => ast::UnaryOp::Not,
};

Call: ast::Call = {
    <primary:Primary> <call:CallPart*> => {
        ast::Call { primary, call }
    }
};

CallPart: ast::CallPart = {
    "." <Ident> => ast::CallPart::Ident(<>),
    "[" <Expr> "]" => ast::CallPart::Brkts(Box::new(<>)),
    "(" <Comma<Expr>> ")" => ast::CallPart::FunCall(<>),
    "?" => ast::CallPart::QMark,
};

Primary: ast::Primary = {
    "(" <Expr> ")" => ast::Primary::Prnth(Box::new(<>)),
    Literal => ast::Primary::Literal(<>),
    "this" => ast::Primary::This,
    Ident => ast::Primary::Ident(<>),
    For => ast::Primary::For(<>),
    While => ast::Primary::While(<>),
    Loop => ast::Primary::Loop(<>),
    If => ast::Primary::If(<>),
    Block => ast::Primary::Block(<>),
};

For: ast::For = {
    "for" <ident:Ident> "in" <expr:Expr> <blk:Block> => {
        ast::For { ident, expr: Box::new(expr), blk }
    }
};

While: ast::While = {
    "while" <expr:Expr> <blk:Block> => {
        ast::While { expr: Box::new(expr), blk }
    }
};

Loop: ast::Loop = {
    "loop" <Block> => {
        ast::Loop { blk: <> }
    }  
};

If: ast::If = {
    "if" <cond:Expr> <blk:Block> <els:Else?> => {
        ast::If { cond: Box::new(cond), blk, els }
    }  
};

Else: ast::Else = {
    "else" <Block> => ast::Else::Block(<>),
    "else" <If> => ast::Else::If(Box::new(<>)),
};

Literal: ast::Literal = {
    "true" => ast::Literal::Bool(true),
    "false" => ast::Literal::Bool(false),
    "null" => ast::Literal::Null,
    Int => ast::Literal::Int(<>),
    Float => ast::Literal::Float(<>),
    Str => ast::Literal::Str(<>),
    Char => ast::Literal::Char(<>),
    Map => ast::Literal::Map(<>),
    Array => ast::Literal::Array(<>),
    StructLit => ast::Literal::Struct(<>),
    Closure => ast::Literal::Closure(<>),
};

Int: i64 = {
    r"\d+" => <>.parse::<i64>().unwrap(),
};

Float: f64 = {
    r"\d+\.\d+" => <>.parse::<f64>().unwrap(),
};

Str: String = {
    r#""(?:[^"\\]|\\.)*""# => <>.into(),
};

Char: char = {
    r"'([^'\\\n]|\\.)'" => <>.chars().next().unwrap(),
};

Map: Vec<ast::MapField> = {
    "map" "{" <Comma<MapField>> "}",
};

MapField: ast::MapField = {
    <key:Str> ":" <val:Expr> => {
        ast::MapField { key, val: Box::new(val) }
    }  
};

Array: Vec<ast::Expr> = {
    "[" <Comma<Expr>> "]",
};

StructLit: ast::StructLit = {
    "new" <ident:Ident> "{" <fields:Comma<StructField>> "}" => {
        ast::StructLit { ident, fields }
    }
};

StructField: ast::StructField = {
    <ident:Ident> ":" <expr:Expr> => {
        ast::StructField { ident, expr: Box::new(expr) }
    }  
};

Closure: ast::Closure = {
    "|" <params:Comma<Ident>> "|" <blk:Block> => {
        ast::Closure { params, blk }
    } 
};

Ident: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.into(),  
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Block: ast::Block = {
    "{" <decls:Decl*> <expr:Expr?> "}" => {
        ast::Block { decls, expr: Box::new(expr) }
    }
};
