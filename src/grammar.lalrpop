use crate::ast;

grammar;

pub Program: () = {
    Decl* => ast::Program { decls: <> },  
};

Decl: () = {
    StructDecl => ast::Decl::Struct(<>),
    FunDecl => ast::Decl::Fun(<>),
    VarDecl => ast::Decl::Var(<>),
    Stmt => ast::Decl::Stmt(<>),  
};

StructDecl: () = {
    "struct" <ident:Ident> "{" <fns:FunDecl*> "}" => {
        ast::StructDecl {
            ident, fns,
        }
    }
};

FunDecl: () = {
    "fn" <ident:Ident> "(" <params:Comma<Ident>> ")" <blk:Block> => {
        ast::FunDecl {
            ident, params, blk,
        }
    }
};

VarDecl: () = {
    "let" <ident:Ident> "=" <expr:Expr> ";" => {
        ast::VarDecl { ident, expr }
    }  
};

Stmt: () = {
    "return" Expr? ";" => ast::Stmt::Return(<>),
    "break" Expr? ";" => ast::Stmt::Break(<>),
    Assignment => ast::Stmt::Assignment(<>),
    Expr ";" => ast::Stmt::Expr(<>),
};

Assignment: () = {
    <call:Call> AssignOp <expr:Expr> ";" => {
        ast::Assignment { call, expr }
    }
};

AssignOp: () = {
    "=" => ast::AssignOp::Assign,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Mod,
    "&=" => ast::AssignOp::BitAnd,
    "|=" => ast::AssignOp::BitOr,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LeftShift,
    ">>=" => ast::AssignOp::RightShift,
    "&&=" => ast::AssignOp::LogicAnd,
    "||=" => ast::AssignOp::LogicOr,
};

Expr: () = {
    LogicOr => ast::Expr::LogicOr(<>),
};

LogicOr: () = {
    LogicAnd => ast::LogicOr::A(<>),
    <left:LogicOr> "||" <right:LogicAnd> => {
        ast::LogicOr::B { left, right }
    }
};

LogicAnd: () = {
    Cmp => ast::LogicAnd::A(<>),
    <left:LogicAnd> "&&" <right:Cmp> => {
        ast::LogicAnd::B { left, right }
    }
};

Cmp: () = {
    BitOr => ast::BitOr::A(<>),
    <left:Cmp> <op:CmpOp> <right:BitOr> => {
        ast::Cmp::B { left, op, right }
    }  
};

CmpOp: () = {
    "==" => ast::CmpOp::Eq,
    "!=" => ast::CmpOp::NotEq,
    "<" => ast::CmpOp::Less,
    ">" => ast::CmpOp::Grt,
    "<=" => ast::CmpOp::LessEq,
    ">=" => ast::CmpOp::GrtEq,
};

BitOr: () = {
    BitXor => ast::BitOr::A(<>),
    <left:BitOr> "|" <right:BitXor> => {
        ast::BitOr::B { left, right }
    }
};

BitXor: () = {
    BitAnd => ast::BitXor::A(<>),
    <left:BitXor> "^" <right:BitAnd> => {
        ast::BitXor::B { left, right }
    }
};

BitAnd: () = {
    Shift => ast::BitAnd::A(<>),
    <left:BitAnd> "&" <right:Shift> => {
        ast::BitAnd::B { left, right }
    }
};

Shift: () = {
    Term => ast::Shift::A(<>),
    <left:Shift> <op:ShiftOp> <right:Term> => {
        ast::Shift::B { left, op, right }
    }
};

ShiftOp: () = {
    ">>" => ast::ShiftOp::Right,
    "<<" => ast::ShiftOp::Left,  
};

Term: () = {
    Factor => ast::Term::A(<>),
    <left:Term> <op:TermOp> <right:Factor> => {
        ast::Term::B { left, op, right }
    }
};

TermOp: () = {
    "+" => ast::TermOp::Add,
    "-" => ast::TermOp::Sub,  
};

Factor: () = {
    TypeCast => ast::Factor::A(<>),
    <left:Factor> <op:FactorOp> <right:TypeCast> => {
        ast::Factor::B { left, op, right }
    }
};

FactorOp: () = {
    "*" => ast::FactorOp::Mul,
    "/" => ast::FactorOp::Div,
    "%" => ast::FactorOp::Mod,  
};

TypeCast: () = {
    Unary => ast::TypeCast::A(<>),
    <left:TypeCast> "as" <type_name:TypeName> => {
        ast::TypeCast::B { left, type_name }
    }  
};

TypeName: () = {
    "bool" => ast::TypeName::Bool,
    "int" => ast::TypeName::Int,
    "float" => ast::TypeName::Float,
    "function" => ast::TypeName::Function,
    "closure" => ast::TypeName::Closure,
    "map" => ast::TypeName::Map,
    "array" => ast::TypeName::Array,
    Ident => ast::TypeName::Ident(<>),
};

Unary: () = {
    Call => ast::Unary::A(<>),  
    <op:UnaryOp> <unary:Unary> => {
        ast::Unary { op, unary }
    }
};

UnaryOp: () = {
    "-" => ast::UnaryOp::Minus,
    "!" => ast::UnaryOp::Not,
};

Call: () = {
    <primary:Primary> <call:CallPart*> => {
        ast::Call { primary, call }
    }
};

CallPart: () = {
    "." Ident => ast::CallPart::Ident(<>),
    "[" Expr "]" => ast::CallPart::Brkts(<>),
    "(" Comma<Expr> ")" => ast::CallPart::FunCall(<>),
    "?" => ast::CallPart::QMark,
};

Primary: () = {
    "(" Expr ")" => ast::Primary::Prnth(<>),
    Literal => ast::Primary::Literal(<>),
    "this" => ast::Primary::This,
    Ident => ast::Primary::Ident(<>),
    For => ast::Primary::For(<>),
    While => ast::Primary::While(<>),
    Loop => ast::Primary::Loop(<>),
    If => ast::Primary::If(<>),
    Block => ast::Primary::Block(<>),
};

For: () = {
    "for" <ident:Ident> "in" <expr:Expr> <blk:Block> => {
        ast::For { ident, expr: Box::new(expr), blk }
    }
};

While: () = {
    "while" <expr:Expr> <blk:Block> => {
        ast::While { expr, blk }
    }
};

Loop: () = {
    "loop" Block => {
        ast::Loop { blk: <> }
    }  
};

If: () = {
    "if" <cond:Expr> <blk:Block> <els:Else?> => {
        ast::If { cond, blk, els }
    }  
};

Else: () = {
    "else" Block => ast::Else::Block(<>),
    "else" If => ast::Else::If(<>),
};

Literal: () = {
    "true" => ast::Literal::Bool(true),
    "false" => ast::Literal::Bool(false),
    "null" => ast::Literal::Null,
    Int => ast::Literal::Int(<>),
    Float => ast::Literal::Float(<>),
    Str => ast::Literal::Str(<>),
    Char => ast::Literal::Char(<>),
    Map => ast::Literal::Map(<>),
    Array => ast::Literal::Array(<>),
    StructLit => ast::Literal::StructLit(<>),
};

Int: () = {
    r"\d+" => <>.parse::<i64>().unwrap(),
};

Float: () = {
    r"\d+\.\d+" => <>.parse::<f64>().unwrap(),
};

Str: () = {
    r#""(?:[^"\\]|\\.)*""#,
};

Char: () = {
    r"'([^'\\\n]|\\.)'",
};

Map: () = {
    "map" "{" Comma<MapField> "}",
};

MapField: () = {
    <key:Str> ":" <val:Expr> => {
        ast::MapField { key, val }
    }  
};

Array: () = {
    "[" Comma<Expr> "]",
};

StructLit: () = {
    "new" <ident:Ident> "{" <fields:Comma<StructField>> "}" => {
        ast::StructLit { ident, fields }
    }
};

StructField: () = {
    <ident:Ident> ":" <expr:Expr> => {
        ast::StructField { ident, expr }
    }  
};

Ident: () = {
    r"[_a-zA-Z][_a-zA-Z0-9]*",  
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Block: () = {
    "{" <decls:Decl*> <expr:Expr?> "}" => {
        ast::Block { decls, expr: Box::new(expr) }
    }
};
